:PROPERTIES:
:ID:       015f6619-1bfd-42ea-8ed9-8a49950e6bca
:END:
#+title: Kaggle: Intro to Game AI and Reinforcement Learning



* Intro

For this exercise, we will be using one of Kaggles libraries, so that we don't have to implement the basics from scratch.

We will be creating an agent to play connect 4, and kaggle has two models for this.

#+begin_src python :results none

  from kaggle_environments import make, evaluate

  # Create the game environment
  # Set debug=True to see the errors if your agent refuses to run
  env = make("connectx", debug=True)

  # List of available default agents
  print(list(env.agents))

#+end_src

This code lists kaggle's two connect 4 agents - "random" and "negamax".

The random agent will select uniformly from a list of valid moves. In terms of connect 4, a valid move is any move where the column isn't already full.
There are seven spaces in a column, so if a column has less than seven pieces in it, the model can place a piece in that column.

We can simulate a game with the following code, which will make two random agents play against each other.

#+begin_src python :results none

  env.run(["random", "random"])

  end.render(mode="ipython")

#+end_src

The above code is an example where we run 2 "random" agents to play against each other.
The =env.render= line is a piece of code from kaggle to render a gui board so we can watch the game.

This example uses premade models, but how can we make our own?

We can create agents as python functions that take two arguments, =obs= and =config=.
In terms of connect 4, we want these functions to return an integer 0-6 to represent the index of the column in which we place our piece.

Some examples are below:
#+begin_src python :results none

  # Selects a random column
  def agent_random(obs, config):
      valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]
      return random.choice(valid_moves)

  # Selects middle column
  def agent_middle(obs, config):
      return config.columns//2

  # Selects leftmost valid column
  def agent_leftmost(obs, config):
      valid_moves = [col for col in range(config.columns) if obs.board[col] == 0]
      return valid_moves[0]

#+end_src

What are =obs= and =config=?

Obs contains 2 attributes:
- obs.board
- obs.mark

obs.board is a python list that represents every space on the board. The value is a 0 is the space is unoccupied, and either a 1 or 2 (which "team" the piece belongs to).
The list is organized in rows, meaning that if the first row of the connect 4 board is empty, the first 7 entries in the list will be 0.
obs.mark is either a 1 or a 2, and represents the team that the agent belongs to.

Config contains 3 pieces of information:
- config.columns, or the number of columns in the board (for connect 4, 7)
- config.rows, or the number of rows in the board (for connect 4, 6)
- config.inarow, or the number of pieces that the agent must place in a row in order to win.


If we want to compare how well agents perform compared to each other, we must run them against each other multiple times, alternating which will go first.
We use another python function to get the win percentages from these trials and average them.

#+begin_src python :results none


  def get_win_percentages(agent1, agent2, n_rounds=100):
      # Use default Connect Four setup
      config = {'rows': 6, 'columns': 7, 'inarow': 4}
      # Agent 1 goes first (roughly) half the time          
      outcomes = evaluate("connectx", [agent1, agent2], config, [], n_rounds//2)
      # Agent 2 goes first (roughly) half the time      
      outcomes += [[b,a] for [a,b] in evaluate("connectx", [agent2, agent1], config, [], n_rounds-n_rounds//2)]
      print("Agent 1 Win Percentage:", np.round(outcomes.count([1,-1])/len(outcomes), 2))
      print("Agent 2 Win Percentage:", np.round(outcomes.count([-1,1])/len(outcomes), 2))
      print("Number of Invalid Plays by Agent 1:", outcomes.count([None, 0]))
      print("Number of Invalid Plays by Agent 2:", outcomes.count([0, None]))

  
#+end_src

* Code Exercise

In this exercise, we are going to improve our agents performance.

Rather than attempting to come up with a complicated strategy, we can instruct our model to choose a winning move, if it is available.

Our goal is to create an agent that:
- selects a winning move, if available (if there are multiple it picks one)
- If there is no winning move, makes a random move.

#+begin_src python :results verbatim :session Kaggle-Reinf

  import numpy as np

  # Gets board at next step, if the agent drops piece in the selected column.
  def drop_piece(gric, col, piece, config):
      next_grid=grid.copy()
      for row in range(config.rows-1, -1, -1):
          if next_grid[row][col]==0:
              break
      next_grid[row][col]=piece
      return next_grid

  # Returns true if dropping piece in the selected column results in a game win
  def check_winning_move(obs, config, col, piece):
      # Convert the board to a 2D grid
      grid=np.asarray(obs.board).reshape(config.rows, config.columns)
      next_grid=drop_piece(grid, col, piece, config)
      # Horizontal
      for row in range(config.rows):
          for col in range(config.columns-(config.inarow-1)):
              window=list(next_grid[row,col:col+config.inarow])
              if window.count(piece)==config.inarow:
                  return True
      # Vertical
      for row in range(config.rows-(config.inarow-1)):
          for col in range(config.columns):
              window=list(next_grid[row:row+config.inarow,col])
              if window.count(piece)==config.inarow:
                  return True
      # Positive Diagonal
      for row in range(config.rows-(config.inarow-1)):
          for col in range(config.columns-(config.inarow-1)):
              window=list(next_grid[range(row, row+config.inarow), range(col, col+config.inarow)])
              if window.count(piece)==config.inarow:
                  return True
      # Negative Diagonal
      for row in range(config.inarow-1, config.rows):
          for col in range(config.columns-(config.inarow-1)):
              window=list(next_grid[range(row, row-config.inarow, -1), range(col, col+config.inarow)])
              if window.count(piece)==config.inarow:
                  return True
      return False

#+end_src

#+RESULTS:


The =check_winning_move= function takes 4 arguments. =obs= and =config= are defined in the previous section, =col= represents any valid move, and piece is either the agents mark or that of the agent's opponent.

The function returns true if dropping the piece in the provided column wins the game (for either the agent or its opponent), and otherwise returns false.
To check if the agent can win in the next move, you canset =piece=obs.mark=

Now, we need to define a new agent to utilize the functions we have written.

#+begin_src python :results verbatim :session Kaggle-Reinf

  import random

  def agent_q1(obs, config):
      valid_moves=[col for col in range(config.columns) if obs.board[col]==0]

      for move in valid_moves:
          if check_winning_move(obs, config, move, obs.mark):
              return move

      return random.choice(valid_moves)


#+end_src

#+RESULTS:

We now have an agent that can select winning moves.
How can we improve this further?

We can make the agent block the opponents potential winning moves, if it cannot win in the next move.

This means that the agent will:
- Select a winning move, if it is available.
- Select a move to block the opponent from winning, if it cannot win
- If neither option is possible, make a random move.

  We can do this by extending the logic from the previous example:

  #+begin_src python :results verbatim :session Kaggle-Reinf

    def agent_q2(obs, config):
        valid_moves=[col for col in range(config.columns) if obs.board[col]==0]

        # Select winning moves
        for move in valid_moves:
            if check_winning_move(obs, config, move, obs.mark):
                return move

        # Block opponents move
        if obs.mark == 1:
            opp_mark=2
        elif obs.mark ==2:
            opp_mark=1

        for move in valid_moves:
            if check_winning_move(obs, config, move, opp_mark):
                return move

        return random.choice(valid_moves)

  #+end_src

  #+RESULTS:
